const private_cert = `-----BEGIN CERTIFICATE-----
MIIEFTCCAv2gAwIBAgIUIsL2t5cmlFZV77nDV7kFk0bQGMYwDQYJKoZIhvcNAQEL
BQAwgagxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQH
Ew1TYW4gRnJhbmNpc2NvMRkwFwYDVQQKExBDbG91ZGZsYXJlLCBJbmMuMRswGQYD
VQQLExJ3d3cuY2xvdWRmbGFyZS5jb20xNDAyBgNVBAMTK01hbmFnZWQgQ0EgYWRi
YmJhOWYzMTkyMzk3YmJmMjRkYjIyY2I3MmYyMjEwHhcNMjEwMTEyMTExMzAwWhcN
MzEwMTEwMTExMzAwWjAiMQswCQYDVQQGEwJVUzETMBEGA1UEAxMKQ2xvdWRmbGFy
ZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALzRoPzpwpJGuoBpJOBN
RCggqnLzqU6wgRWrmU+M9z+1yWZ+G/oBZNlT2fi/mC9wu+XWOnMhCiYzfXBOgUnI
YdKwZoeHXDuYHgWjP75nDtwA5TOHe+OOdXU6BUpioKJaD1lQGfz/Ll4Xmk1kwUtn
XlE/OlNaKq+48kNqOAp+VSdR3eUAuyGW7DUUdNvZAl2ap0eLXpWGhCj5YW4/Eyna
38c2g7KNF2YNDgq5r0sLZWPOrjitFnq2hsn4tJmom44VM2ALqkk3mEYoBfYFAQG3
Fo+oiIq6pNogodlf+JVYyNMzKGLRBir2XBMUBFiBlmbajZh+ATH7Gngj5IacrZ3f
zsUCAwEAAaOBuzCBuDATBgNVHSUEDDAKBggrBgEFBQcDAjAMBgNVHRMBAf8EAjAA
MB0GA1UdDgQWBBSRYlDSAR4DdGZlJ2fefMni9rPFWTAfBgNVHSMEGDAWgBSmkvas
thbz56XoVnHK4/VmEl6vODBTBgNVHR8ETDBKMEigRqBEhkJodHRwOi8vY3JsLmNs
b3VkZmxhcmUuY29tL2Q3YWRlZDU3LTNlZGEtNGRlZS1iYTEwLTAzMzFiZGFkMmY3
NC5jcmwwDQYJKoZIhvcNAQELBQADggEBAE7iEXlN511ele484G/H9d0vrV9mZM4P
+BaoPyZfisVEy/E0XSPuFnaG7SVSq+W6kq0rXGMI4a8tzoCQO+E4nJiITOU1jrxq
GONjoBJgwDKDJ6Ucx1yndNr7hUPldBzJSGonyWW7al9VxB+Kfx3zEsNQAIkfgZdD
YLBq0r7KqOjMM9D3ZesR+H+WbI1ZZ9w6e4RcSnulNRZ/w0yhiHKmTqUI7KQZHI/O
uaLr2fvf1DieI6wgIjb6xOB/TD64VoZJGWubYJFchIWs4eDgOaCjCRhnE7YlnI1w
1YDufbhmmEZzUn8435Rpt/zZzqeKP1VlWtH+1Bqjrj5G+Pm4YVGgVSc=
-----END CERTIFICATE-----`

const private_key = `-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC80aD86cKSRrqA
aSTgTUQoIKpy86lOsIEVq5lPjPc/tclmfhv6AWTZU9n4v5gvcLvl1jpzIQomM31w
ToFJyGHSsGaHh1w7mB4Foz++Zw7cAOUzh3vjjnV1OgVKYqCiWg9ZUBn8/y5eF5pN
ZMFLZ15RPzpTWiqvuPJDajgKflUnUd3lALshluw1FHTb2QJdmqdHi16VhoQo+WFu
PxMp2t/HNoOyjRdmDQ4Kua9LC2Vjzq44rRZ6tobJ+LSZqJuOFTNgC6pJN5hGKAX2
BQEBtxaPqIiKuqTaIKHZX/iVWMjTMyhi0QYq9lwTFARYgZZm2o2YfgEx+xp4I+SG
nK2d387FAgMBAAECggEAHzToThSWb1WYOmPmT9oFUzp+4UvLJjG+y+WWC5NJQ/LY
DAP4vLuhPtgAdP+5d9HChEyBUYja5BBrgXXAIYEoRcmY0Hp7MHBGOflOrjnbN1pA
h2EzhRsE57CEslQVp2+KDOFTwkAsmil9e6AU4FD/wh7YlXEYD/3ZsHGsPHO/wCUa
z8pxSPsqnbNxv4ozZOrSjLza7z2nh+46uT1wYMS6PVx3RZ1hgMbkFkZJP96TDBuY
QgoVFFPUet3QVQmk/bxKw6xxekcHZqG/QY0QS77lkp4RyWgXkVt+FOD7gV/eCPCy
w1fJCKNFsUonGS5h6Qnipk2PmALYzGry7eiePxDQywKBgQD8fY856SO5cZXCymmW
NSvYz3HaCuIJYlVQ7s4XysBwUuhEjMWo+tavH/1FSIH8ngLUsnetgcU6LR0TeyIJ
PvalmLRU6t/uxpbd0t20oAVj/+sEe1fzFagbyI+gkbgEc2d7Ch4wii+tB7pN6Gd+
Wtc61GaBGlH5xkX42LSf7qNpxwKBgQC/cYF65mctfwkOAfq0KJHMb2R7sCYWE/e6
VoaU0LmUc9P+IFzxLKdWG+xGIO9rPPikCR0TQ1jS+MQ/+NcwZJ7LzBAta6kUZQKG
CwPNdKICIKpTog3PjGhe6vAHaUKw51jp6NuSaZ39G8e/ON4wf7vP1jPveDXIYJG5
yikj03FjEwKBgEZ85xdLtuV2iFCxIXkFrxAAGdC9aQ0lnpvRj0elGsRA4QcCJcxe
+sA5NgO5klBr7G5kxHRz3hO3tH5TydS69zCTyQRL7ehDGKskyzA53Edmkr3VkWAT
k7Lt8urow266qRD4aiUy7sxnc+N8Fih4Q83wrg0sw+XvLGmkVgiwHn7RAoGAMCA9
l4KyL1q/EPloZ7/HHyhljz5x5JzyarJztJdf/7S6dyj1lF9QVbJBTEPdTA0QyFPO
LliAzNBirV5F4lF5JexPqMtmvszBvKaqNwz56SUDDHExnZpDZpES9Bn+/O+7h1nV
UNIiOE2yghyupmyF7zJ+7dU/V/cGyzjJ7Mqrt2cCgYEAzKuwLoE/DpXoWPQRSM2x
vZpau4pj7ed+DTBphKW+ybXiljOj2ucrlKxklSKTwP0NgowHyfKRMjHR5EUBnNw3
C8qd4HIzBsdu5phUi9ey3QRfT9YQnLOP1+FaN8coI5Y4dfJJGfJAy852tMKZHF6f
488wjkrjm6zV54PNq9cKLcw=
-----END PRIVATE KEY-----`

addEventListener("fetch", event => {
  const url = new URL(event.request.url);
  const uri = url.pathname;
  if (uri.includes("getTeamRepo") && event.request.method === 'GET') {
    event.respondWith(getTeamRepo(event))
  }else{
    // Will return the certificates needed and code base of the runners.
    event.respondWith(fetchData(event))
  }

})


async function fetchData(event) {
  // Check if user is authed
  const authResponse = await authenticate(event)
  // return authResponse
  if (authResponse.status !== 200) {
    // User is not authentocated so reject and show message in auth worker.
    return authResponse
  }
  const requestURL = new URL(event.request.url)
  const path = requestURL.pathname

  // Modify the rest of the code to make a call to the runner GitHub repo and 
  //  still utilise proper caching.
  var username = "JamesWRC"
  var githubAccessToekn = ""
  var repo = ""
  var url = ""
  // name is JamesWRC-pacman-ai-runner-(hash).zip This is used for file name splitting and 
  // for getting the name and release/zip hash.
  var repoZipName = "JamesWRC-pacman-ai-runner-"
  if (String(path) === "/runner") {
    githubAccessToekn = PACMAN_AI_GAMECODE
    repo = "pacman-ai-temp-code"
    url = "https://api.github.com/repos/JamesWRC/pacman-ai-temp-code/zipball/master"
    repoZipName = "JamesWRC-pacman-ai-temp-code-"
  } else {
    githubAccessToekn = PACMAN_AI_RUNNER_CODE
    repo = "pacman-ai-runner"
    url = "https://api.github.com/repos/JamesWRC/pacman-ai-runner/zipball/master"
    repoZipName = "JamesWRC-pacman-ai-runner-"
  }


  const init = {
    headers: {
      "Content-Type": "application/json",
      "User-Agent": "PostmanRuntime/7.26.8",
      "Authorization": "token " + String(githubAccessToekn),
      'Accept': 'application/vnd.github.v3+json'
    },
    method: "GET"
  }



  const resp = await fetch(url, init)
  var response = new Response(resp.body, resp)
  //   console.log(response)
  //   return response

  // Only alter headers if getting codebase to install and run etc
  if (String(path) !== "/runner") {
    response.headers.set("X-PACMAN-PRIVATE-CERT", btoa(private_cert))
    response.headers.set("X-PACMAN-PRIVATE-KEY", btoa(private_key))
  }

  var gitHubReleaseHash = response.headers.get("Content-Disposition").split(repoZipName)[1].split(".zip")[0];
  // Get the hash from the end of the string. for some reason there is random stuff at the start of the string.
  if(gitHubReleaseHash.length>40){
    gitHubReleaseHash = gitHubReleaseHash.substr(gitHubReleaseHash.length - 40);
  }

  response.headers.set("X-GITHUB-RELEASE-VERSION", gitHubReleaseHash)
  response.headers.set("X-PACMAN-ZIPNAME", repoZipName.substring(0, repoZipName.length - 1))
  response.headers.set("Content-Disposition", "attachment; filename=ZippedCodebase.zip")

  return response
}

async function authenticate(event) {
  var userKey = ""
  userKey = event.request.headers.get("userKey")
  if (userKey) {
    const headers = {
      headers: {
        "content-type": "application/json;charset=UTF-8",
        "userKey": String(userKey)
      },
    }

    const url = "https://auth.pacman.workers.dev"
    const resp = await fetch(url, headers)

    // Check authentication of user 
    return new Response(resp.body, resp)
  }

  // User has not specified the 'userKey' header. 
  var error = JSON.stringify({ "error": "'userKey' header not specified. This key is geven to you on signing up your organization. This key is required for all requests, in combination with your TLS cert and key." })

  return new Response(error,
    {
      headers: {
        "content-type": "application/json",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET,HEAD,POST,OPTIONS",
        "Access-Control-Max-Age": "86400",
        "Access-Control-Allow-Headers": "Access-Control-Allow-Headers, Origin,Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers, gameData, contentType, sessionID, serverID"
      },
      method: 'GET',
      statusText: "User Not Authenticated.",
      status: 401
    })
}
async function getBody(request) {
  try {
    const body = await request.text()
    return JSON.parse(body)
  } catch (err) {
    return ""
  }
}

async function getTeamRepo(event){
  // Check if user is authed
  const authResponse = await authenticate(event)
  // return authResponse
  if (authResponse.status !== 200) {
    // User is not authentocated so reject and show message in auth worker.
    return authResponse
  }

  const url = event.request.url

	// Function to parse query strings
	function getParameterByName(name) {
		name = name.replace(/[\[\]]/g, '\\$&')
		name = name.replace(/\//g, '')
		var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
			results = regex.exec(url)

		if (!results) return null
		else if (!results[2]) return ''
		else if (results[2]) {
			results[2] = results[2].replace(/\//g, '')
		}
		
		return decodeURIComponent(results[2].replace(/\+/g, ' '));
	}

  var teamName = getParameterByName('teamName')
  try{
    teamName = encodeURIComponent(teamName)
    console.log("url encode")
    console.log(decodeURIComponent(teamName))

  }catch(err){
    return new Response(JSON.stringify({ "success": false, "errorCode": 999, "msg": "System does not like this name. Try another."}), {
      headers: {
        "access-Control-Allow-Origin": "*",
        "access-Control-Allow-Headers": "Access-Control-Allow-Headers, Origin,Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, Access-Control-Request-Headers, gameData, contentType, contenttype, access-control-allow-origin",
        "content-type": "application/json;charset=UTF-8",
      }
    })
  }
    const valueAndMetadata = await TEAMS.getWithMetadata(teamName)
    const value = valueAndMetadata.value
    const metadata = valueAndMetadata.metadata

    const gitToken = metadata.gitToken;
    const gitUsername = metadata.gitUsername;
    const gitRepoName = metadata.gitRepo;

    const gitDefaultBranchURL = `https://api.github.com/repos/${gitUsername}/${gitRepoName}`


    const init = {
      headers: {
        "Content-Type": "application/json",
        "User-Agent": "PostmanRuntime/7.26.8",
        "Authorization": "Bearer " + String(gitToken),
        'Accept': 'application/vnd.github.v3+json'
      },
      method: "GET"
    }


    // get the default branch of the users repo
    const gitRepoDefaultBranchResponse = await fetch(gitDefaultBranchURL, init)
    const gitDefaultBranchData = await getBody(gitRepoDefaultBranchResponse);
    const gitDefaultBranch = gitDefaultBranchData.default_branch

    // get the (latest) default branch commit hash
    const gitRepoBranchURL = `https://api.github.com/repos/${gitUsername}/${gitRepoName}/branches/${gitDefaultBranch}`
    const gitBranchDataResponse = await fetch(gitRepoBranchURL, init)
    const getBranchData = await getBody(gitBranchDataResponse);
    const gitBranchHash = getBranchData.commit.sha;

    // get the tarball of the default branch's latest commit
    const gitLatestCommitContentsURL = `https://api.github.com/repos/${gitUsername}/${gitRepoName}/tarball/${gitBranchHash}`
    const gitRepoFileResponse = await fetch(gitLatestCommitContentsURL, init)
    var gitRepoFileResponseToReturn = new Response(gitRepoFileResponse.body, gitRepoFileResponse)

    // Set headers with content for the repo
    gitRepoFileResponseToReturn.headers.set("X-DEFAULT-BRANCH", gitDefaultBranch)
    gitRepoFileResponseToReturn.headers.set("x-BRANCH-COMMIT-HASH", gitBranchHash)

    // Return the github repo payload with headers of info about the payload.
    return gitRepoFileResponseToReturn;


  // var response = new Response(resp.body, resp)


}